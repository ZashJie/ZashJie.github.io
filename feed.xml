<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>岚雲</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2024-02-29T15:05:07+00:00</updated> <author> <name>ZashJie</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 ZashJie </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>6.s081 lab7 Multhreading</title><link href="/posts/6.s081-lab7-Multhreading/" rel="alternate" type="text/html" title="6.s081 lab7 Multhreading" /><published>2024-02-10T02:34:00+00:00</published> <updated>2024-02-10T02:34:00+00:00</updated> <id>/posts/6.s081-lab7-Multhreading/</id> <content src="/posts/6.s081-lab7-Multhreading/" /> <author> <name>ZashJie</name> </author> <category term="计算机" /> <summary> #操作系统/6S081 Uthread: switching between threads 题目一开始就提供的 uthread.c 实验目的 补充一个三线程一次从0增加到100，在题目给出的代码中，缺少的是： 线程间寄存器的切换 汇编代码 线程的上下文定义 线程上下文的初始化 要着重注意 返回地址 和 栈指针指向 - user/uthread.c code #include "kernel/types.h" #include "kernel/stat.h" #include "user/user.h" /* Possible states of a thread: */ #define FREE 0x0 #define RUNNING 0x1 #define RUNNABLE ... </summary> </entry> <entry><title>6.s081 lab6 - copy-on-write fork</title><link href="/posts/6.s081-lab6-copy-on-write-fork/" rel="alternate" type="text/html" title="6.s081 lab6 - copy-on-write fork" /><published>2024-02-10T02:34:00+00:00</published> <updated>2024-02-10T02:34:00+00:00</updated> <id>/posts/6.s081-lab6-copy-on-write-fork/</id> <content src="/posts/6.s081-lab6-copy-on-write-fork/" /> <author> <name>ZashJie</name> </author> <category term="计算机" /> <summary> #操作系统/6S081 什么是 COW 这是懒分配的一个方法，在fork的时候 让子进程一起使用父进程的内存，避免fork占有无意义的内存，在当占有的内存被使用时，才开始创建新的内存 实现要点 要怎么实现fork分配后，子进程使用父进程内存； 系统怎么知道你是父进程跟子进程一起使用的 通过COW处理的内存； 在子进程分配后，父进程虚拟页表并没有被处理，如何防止父进程的内存被再次分配； 父子进程指向同一个虚拟内存时，如何保证物理地址不被重复释放； 物理页表的引用计数，如何避免静态竞争导致所导致的错误； - 大概要点就这么多吧 代码实现 kernel/kalloc.h ```c ===- struct spinlock pgreflock; #define paNum(pa) ((pa - KERNBASE)/PGSIZE) #define PG_... </summary> </entry> <entry><title>xv6 console.c 文件代码解析</title><link href="/posts/xv6-console.c-%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="alternate" type="text/html" title="xv6 console.c 文件代码解析" /><published>2024-01-27T02:34:00+00:00</published> <updated>2024-01-27T02:34:00+00:00</updated> <id>/posts/xv6-console.c-%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</id> <content src="/posts/xv6-console.c-%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" /> <author> <name>ZashJie</name> </author> <category term="计算机" /> <summary> #操作系统/6S081/源码解析 源代码地址 void consputc(int c) 当遇到退格符时，执行 uartputc_sync('\b'); uartputc_sync(' '); uartputc_sync('\b'); 代码 该代码的作用是 将光标往前移动一个，在输出空格覆盖，再将光标往前移动一格。 如果不是退格符，则执行 uartputc_sync 将字符输出 void uartputc_sync(int c) 能够以不中断的情况下，通过轮询等待串口空闲时，向串口发送字符 调用 `put_off` 关闭中断，循环 `ReadReg(LSR)` 读取 (Transmit Holding Empty，LSR_TX_IDLE)为空 表示串口能够接收字符了，调用 `WriteReg(THR, c)` 写入到 THR 寄存器之中，最后 调用 `pop_off()` 开启中... </summary> </entry> <entry><title>xv6 源码解析 - kerneltrap函数</title><link href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-kerneltrap%E5%87%BD%E6%95%B0/" rel="alternate" type="text/html" title="xv6 源码解析 - kerneltrap函数" /><published>2024-01-21T02:34:00+00:00</published> <updated>2024-01-21T02:34:00+00:00</updated> <id>/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-kerneltrap%E5%87%BD%E6%95%B0/</id> <content src="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-kerneltrap%E5%87%BD%E6%95%B0/" /> <author> <name>ZashJie</name> </author> <category term="计算机" /> <summary> #操作系统/6S081/源码解析 code // interrupts and exceptions from kernel code go here via kernelvec, // on whatever the current kernel stack is. void kerneltrap() { int which_dev = 0; uint64 sepc = r_sepc(); uint64 sstatus = r_sstatus(); uint64 scause = r_scause(); if((sstatus &amp;amp; SSTATUS_SPP) == 0) panic("kerneltrap: not from supervisor mode"); if(intr_get() != 0) panic("kernel... </summary> </entry> <entry><title>xv6 源码解析 - vmcreate 函数</title><link href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-vmcreate-%E5%87%BD%E6%95%B0/" rel="alternate" type="text/html" title="xv6 源码解析 - vmcreate 函数" /><published>2024-01-20T02:34:00+00:00</published> <updated>2024-01-20T02:34:00+00:00</updated> <id>/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-vmcreate-%E5%87%BD%E6%95%B0/</id> <content src="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-vmcreate-%E5%87%BD%E6%95%B0/" /> <author> <name>ZashJie</name> </author> <category term="计算机" /> <summary> #操作系统/6S081/源码解析 code // create an empty user page table. // returns 0 if out of memory. pagetable_t uvmcreate() { pagetable_t pagetable; pagetable = (pagetable_t) kalloc(); if(pagetable == 0) return 0; memset(pagetable, 0, PGSIZE); return pagetable; } 解析 函数流程 通过调用 kalloc 函数获取到没有被使用到的物理内存，并强制类型转换成 pagetable_t，并作为返回值返回 需要多思考的点 函数分配的内容大小为 4096 bytes 但是能够... </summary> </entry> </feed>
