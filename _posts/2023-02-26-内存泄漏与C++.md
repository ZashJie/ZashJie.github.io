---
title: 内存泄漏与C++
date: 2023-02-26 10:34:00 +0800
categories: [计算机]
tags: [语言/CPP]
pin: false
author: ZashJie

toc: true
comments: true
typora-root-url: ../../ZashJie.github.io
math: false
mermaid: true


---


#语言/CPP  
### 定义
申请了一块内存空间，使用完毕后没有释放掉。它的表现是程序运行的时间越长，占用的内存越多，最终用尽全部内存。

## 涉及到内存泄漏

[[堆区和栈区的区别]]
### 栈
由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是*局部变量*和*函数参数*等。
它是连续的空间，在函数调用的时候，首先入栈的是主函数的下一条可执行指令的地址，然后才是各个参数。
⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤ [[C++的“函数参数⻓度可变”特性]]时更⽅便。如果是从左向右压栈，第⼀个参数（即描述 可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）

	 如果第一个参数在栈底，我们就需要遍历整个栈才能找到它，这样效率很低。而如果第一个参数在栈顶，
	 我们就可以直接访问它，然后根据它的信息来处理后面的参数

栈是⾼地址向低地址扩展，栈底⾼地址，空间较⼩。

### 堆
由程序员管理，需要⼿动 [[C++ new delete 跟 malloc free]] 进⾏分配和回收，如果不进⾏回收的话，会造成[[内存泄漏]]的问题。

##### 分配方式
它是不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到 第⼀个**⼤于等于**申请⼤⼩的空间分配给程序，⼀般在分配空间的时候，也会在空间头部写⼊内存⼤⼩，⽅便 `delete` 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。

堆是低地址向⾼地址扩展，空间较⼤，较为灵活。

### 什么情况下使用堆区什么情况使用栈区

一般情况下，当需要分配一块**较小的内存且其大小是固定的**，或者需要在函数调用期间使用的局部变量时，可以使用栈区分配内存。当需要分配一块较大的内存，或者需要在函数外部访问的变量时，应该使用堆区分配内存。

但是，需要注意的是，在使用堆区分配内存时需要注意内存泄漏和内存泄漏问题，一旦内存泄漏发生，将导致系统的内存资源被耗尽，并可能导致程序崩溃。因此，在使用堆区分配内存时，应该小心谨慎，确保适当地释放内存以避免出现这些问题。


[[C++ 智能指针]]
智能指针的作用就是管理一个指针，避免程序员申请的空间在函数结束的时候忘记将释放掉，造成[[内存泄漏]]的发生

形象来说，智能指针就是一个类，当超出这个类的时，就会自动调用析构函数自动释放资源。


[[C++ new delete 跟 malloc free]]
### 基本概念

`new/delete` 是 **运算符**，`malloc/free`是 **库函数**，他们都可以在堆上分配和回收内存空间

`new` 会调用 `malloc` 分配未初始化的内存空间，然后使用**构造函数**对空间进行初始化；
`delete` 先使用析构函数对对象进行**析构**，然后再调用 `free` 回收内存空间

而malloc的作用只能分配出未初始化的空间，`free` 只能回收释放内存空间

> 运算符 是编译器定义好的行为
> 函数 是自包含的代码单元
### 总结

对于非内部数据而言，光用 `malloc/free` 是不能够满足对象的需求，即在`new`分配空间的时候，帮助你自动执行构造函数，在`delete`释放空间的时候，帮你自动执行析构函数
又因为 `malloc/free` 是库函数不是运算符，不在编译器的控制权限内，所以不能够把执行构造和析构的操作强加于 `malloc/free` 操作
所以这就是为什么需要 `new` 跟 `delete` 运算符的原因

### 手动创建跟释放资源的隐患
通过 `new/delete` `malloc/free` 创建的空间都是在堆中 由程序员手动管理，如果在创建后不手动回收释放资源的话，就会导致[[内存泄漏]]的问题产生