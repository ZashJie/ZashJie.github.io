---
title: TCP四次挥手
date: 2023-02-01 10:34:00 +0800
categories: [计算机]
tags: [网络/TCP]
pin: false
author: ZashJie

toc: true
comments: true
typora-root-url: ../../ZashJie.github.io
math: false
mermaid: true


---


#网络/TCP

## 概要

当要进行断开连接时，连接的双方都可以通过四次握手将连接断开，断开连接后，主机的资源将被释放

## 具体过程

由于双方都可以发送连接，所以我将第一个发送`FIN`报文的一方称为发送方，另一方为接收方
##### 第一次挥手
在发送方保证自己没有要处理和发送的数据后，向接收方发送`FIN`报文，之后发送方状态从 `ESTABLISHED` 状态转变为 `FIN_WAIT1` 状态

##### 第二次挥手
接收方接收了发送来的FIN请求报文，同意后，向发送方发送`ACK`应答报文，因为可能还有数据要处理和发送，接收方状态从 `ESTABLISHED` 状态转变为 `CLOSE_WAIT` 的状态

##### 第三次挥手
在接收方处理完数据后，向发送方发送`FIN`请求报文，状态从 `CLOSE_WAIT` 转变为 `LAST_WAIT` 状态

##### 第四次挥手
发送方收到后，向接收方发送`ACK`应答报文，状态从 `FIN_WAIT2` 转变为 `TIME_WAIT` 状态，在`2MSL`时间后，状态自动转变为`CLOSE`

接收方接收到发送方发来的应答报文，状态就从 `LAST_WAIT` 转变为 `CLOSE` 了

## 深层问题

### 什么情况会出现三次挥手呢

首先要搞清楚什么是三次挥手，三次挥手就是将接收方发送的FIN报文跟ACK报文合并在一起发送
那么什么情况会合并在一起发送呢
首先不合并在一起发送是因为 `FIN` 报文的发送可能需要等待接收方的处理完数据在发送

##### 条件
在数据处理完时以及开启了 **TCP延迟确认机制** 时就会出现三次挥手的情况发生

##### TCP延迟确认机制
因为在TCP报文中没有携带数据的ACK报文是低效的，比较浪费资源，所以有了这个TCP延迟确认机制尽量让数据跟ACK报文一起发送
- 当有数据要响应时，ACK会随着响应数据一起立刻发送给对方
- 当没有数据要响应，ACK报文就会等待一段时间，看有没有数据需要一起发送

### 为什么接收方要有一个2MSL的 `TIME_WAIT` 状态

##### 为什么发送方在连接关闭时，需要有一个 `TIME_WAIT` 状态
- 为了防止历史连接中的数据，被相同四元组的连接 错误接收
- 保证接收方能够正确关闭连接

##### 为什么 `TIME_WAIT` 状态持续时间为 2MSL
MSL的英文全称是 `Maximum Segment Lifetime` 就是一个报文的最大生存时间，也就是说报文一来一回所用的最长时间就是2MSL
所以能够保证在发送方一次应答报文丢失，产生一次超时重传，来保证接收方连接的关闭

### 为什么服务端出现大量的 `close_wait` 状态

服务端如果要进行第三次握手，那么服务端需要调用 `close()` 函数
所以出现这种情况的根本原因有两点：
- 服务端线程阻塞，导致无法调用close()函数
- 调用close()函数出现大量耗时的逻辑