<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="xv6 console.c 文件代码解析" /><meta name="author" content="ZashJie" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="#操作系统/6S081" /><meta property="og:description" content="#操作系统/6S081" /><link rel="canonical" href="/posts/6.S081-lab3-pgtbl/" /><meta property="og:url" content="/posts/6.S081-lab3-pgtbl/" /><meta property="og:site_name" content="岚雲" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-05T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="xv6 console.c 文件代码解析" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@ZashJie" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"ZashJie"},"dateModified":"2024-01-05T02:34:00+00:00","datePublished":"2024-01-05T02:34:00+00:00","description":"#操作系统/6S081","headline":"xv6 console.c 文件代码解析","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/6.S081-lab3-pgtbl/"},"url":"/posts/6.S081-lab3-pgtbl/"}</script><title>xv6 console.c 文件代码解析 | 岚雲</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="岚雲"><meta name="application-name" content="岚雲"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">岚雲</a></div><div class="site-subtitle font-italic">这里是岚雲的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/ZashJie" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>xv6 console.c 文件代码解析</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>xv6 console.c 文件代码解析</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1704422040" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2024/01/05 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2999 字"> <em>16 分钟</em>阅读</span></div></div></div><div class="post-content"><p>#操作系统/6S081</p><h2 id="打印页表"><span class="mr-2">打印页表</span><a href="#打印页表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="实验要求以及注意点"><span class="mr-2">实验要求以及注意点</span><a href="#实验要求以及注意点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>将每一级对应的页表映射打印输出出来，打印出每个 pte 对应的 物理地址<li>可以参照 <code class="language-plaintext highlighter-rouge">freewalk</code> 函数是怎么遍历三级页表找到最终的物理地址的<li>不要打印非法的pte，也就是没有分配的pte是不需要进行打印的<li></ol><h3 id="所需的源码理解"><span class="mr-2">所需的源码理解</span><a href="#所需的源码理解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>[[xv6 源码解析 - pagetable_t]]</p><p>[[xv6 源码解析 - pte]]</p><h5 id="pte2pa"><span class="mr-2">PTE2PA</span><a href="#pte2pa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p><code class="language-plaintext highlighter-rouge">#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</code> 这是一个宏，作用是将 pte 转换成 物理地址 pte 的后10位是对应的标志位，所以向后移10位将对应的标志位信息抹消掉，而向左移动12位的原因是为了跟 offset 的12位进行对齐（PTE - 44位物理地址 + 10位标志位 | PPN - 44位物理地址 + 12位offset）</p><h5 id="kfree"><span class="mr-2">kfree</span><a href="#kfree" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>将物理页释放掉，并返回到 空闲链表 头中</p><h5 id="walk"><span class="mr-2"><code class="language-plaintext highlighter-rouge">walk()</code></span><a href="#walk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>将通过传来的</p><h3 id="code"><span class="mr-2">code</span><a href="#code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>```C
void
vmprint(pagetable_t pagetable, int depth) {
if (depth &gt;= 3) return;
if (depth == 0)
	printf("page table %p\n", pagetable);
for (int i = 0; i &lt; 512; i++) {
	int d = depth;
	pte_t pte = pagetable[i];
	if (pte &amp; PTE_V) {
	while (d--) {
		printf(".. ");
	}
	uint64 child = PTE2PA(pte);
	printf("..%d: pte %p pa %p\n", i, pte, child);

	vmprint((pagetable_t)child, depth + 1);
	}
}
}
```
</pre></table></code></div></div><h5 id="为什么打印出来的页表一个在他头一个在尾并且为什么尾的根页表不是511而是255"><span class="mr-2">为什么打印出来的页表一个在他头一个在尾，并且为什么尾的根页表不是511而是255</span><a href="#为什么打印出来的页表一个在他头一个在尾并且为什么尾的根页表不是511而是255" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>位于尾页表的是陷阱，并且实际上使用只用了38位，所以根页表最大在255 <code class="language-plaintext highlighter-rouge">c page table 0x0000000087f6e000 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000 .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 </code></p><h2 id="每个进程拥有自己的内核页表"><span class="mr-2">每个进程拥有自己的内核页表</span><a href="#每个进程拥有自己的内核页表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="实验要点"><span class="mr-2">实验要点</span><a href="#实验要点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>在 <code class="language-plaintext highlighter-rouge">struct proc</code> 为每个进程添加一个物理页表<li>生成一个新的页表给进程（在 <code class="language-plaintext highlighter-rouge">allocproc </code> 函数中）<li>确保每个进程的内核页表映射进程的内核栈（内核栈的设置都在 <code class="language-plaintext highlighter-rouge">proinit</code> 中，我们可以将其移动到 <code class="language-plaintext highlighter-rouge">allocproc</code> 中实现）<li>在 <code class="language-plaintext highlighter-rouge">scheduler</code> 函数中调用<li>在没有进程运行时，<code class="language-plaintext highlighter-rouge">scheduler</code> 函数 应该使用原本的 <code class="language-plaintext highlighter-rouge">kernel_pagetable</code><li>释放进程的内核页表在 <code class="language-plaintext highlighter-rouge">freeproc</code><li>需要另一种方式释放内核页表，同时不释放物理页<li>-</ol><h3 id="疑问"><span class="mr-2">疑问</span><a href="#疑问" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>每个进程的内核栈还是要分配一个物理地址吧 要给内核栈独立分配一个地址，不过映射在进程的内核页表上 物理页不释放，到时候给谁用？不释放的原因 不能够释放进程内核页表 虚拟内存 对应的 物理内存，因为会将内核的物理内存给释放掉</p><h3 id="code-1"><span class="mr-2">code</span><a href="#code-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
</pre><td class="rouge-code"><pre>##### `kernel/vm.c`
```c
// kernel/vm.c
pagetable_t
kvm_map_kernalpagetable() {
pagetable_t pgtbl = (pagetable_t) kalloc();
memset(pgtbl, 0, PGSIZE);

// uart registers
kvmmap(pgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

// virtio mmio disk interface
kvmmap(pgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

// CLINT
kvmmap(pgtbl, CLINT, CLINT, 0x10000, PTE_R | PTE_W);

// PLIC
kvmmap(pgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

// map kernel text executable and read-only.
kvmmap(pgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

// map kernel data and the physical RAM we'll make use of.
kvmmap(pgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

// map the trampoline for trap entry/exit to
// the highest virtual address in the kernel.
kvmmap(pgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

return pgtbl;
}

void
kvminit()
{
kernel_pagetable = kvm_map_kernalpagetable();
}

void
kvmmap(pagetable_t pgtbl, uint64 va, uint64 pa, uint64 sz, int perm)

uint64
kvmpa(pagetable_t pgtbl, uint64 va)

void
uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)

void
kvm_free_mapping(pagetable_t pgtbl) {
for (int i = 0; i &lt; 512; i++) {
	pte_t pte = pgtbl[i];
	if ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W)) == 0) {
	uint64 child = PTE2PA(pte);
	kvm_free_mapping((pagetable_t)child);
	pgtbl[i] = 0;
	}
}
kfree((void*) pgtbl);
}
```
##### `kernel/proc.c`
```C
void
procinit(void)
{
struct proc *p;

initlock(&amp;pid_lock, "nextpid");
for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
	initlock(&amp;p-&gt;lock, "proc");

	// delete 
	
	// char *pa = kalloc();
	// if(pa == 0)
	//   panic("kalloc");
	// uint64 va = KSTACK((int) (p - proc));
	// kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
	// p-&gt;kstack = va;
	
	// delete
}
kvminithart();
}

static struct proc*
allocproc(void) {
// ...
// An empty user page table.
p-&gt;pagetable = proc_pagetable(p);
if(p-&gt;pagetable == 0){
	freeproc(p);
	release(&amp;p-&gt;lock);
	return 0;
}

// insert start
char *pa = kalloc();
if (pa == 0) {
	panic("kalloc");
}
uint64 va = KSTACK(0);
p-&gt;kernel_pagetable = kvm_map_kernalpagetable();
kvmmap(p-&gt;kernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R|PTE_W);
p-&gt;kstack = va;

// insert over

memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));
p-&gt;context.ra = (uint64)forkret;
p-&gt;context.sp = p-&gt;kstack + PGSIZE;
return p;
}

static void
freeproc(struct proc *p)
{
if(p-&gt;trapframe)
	kfree((void*)p-&gt;trapframe);
p-&gt;trapframe = 0;
if(p-&gt;pagetable)
	proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
p-&gt;pagetable = 0;
p-&gt;sz = 0;
p-&gt;pid = 0;
p-&gt;parent = 0;
p-&gt;name[0] = 0;
p-&gt;chan = 0;
p-&gt;killed = 0;
p-&gt;xstate = 0;

// insert start
kfree((void*)kvmpa(p-&gt;kernel_pagetable, p-&gt;kstack));
p-&gt;kstack = 0;
kvm_free_mapping(p-&gt;kernel_pagetable);
p-&gt;kernel_pagetable = 0;
// insert over

p-&gt;state = UNUSED;
}

void
scheduler(void)
{
struct proc *p;
struct cpu *c = mycpu();

c-&gt;proc = 0;
for(;;){
	// Avoid deadlock by ensuring that devices can interrupt.
	intr_on();
	
	int found = 0;
	for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
	acquire(&amp;p-&gt;lock);
	if(p-&gt;state == RUNNABLE) {

		p-&gt;state = RUNNING;
		c-&gt;proc = p;
		
		// insert start
		w_satp(MAKE_SATP(p-&gt;kernel_pagetable));
		sfence_vma();
		// insert over
		
		swtch(&amp;c-&gt;context, &amp;p-&gt;context);
		
		// insert start
		kvminithart();
		//insert over

		c-&gt;proc = 0;

		found = 1;
	}
	release(&amp;p-&gt;lock);
	}
#if !defined (LAB_FS)
	if(found == 0) {
	intr_on();
	asm volatile("wfi");
	}
#else
	;
#endif
}
}
```
</pre></table></code></div></div><h3 id="简化-copyin-copyinstr"><span class="mr-2">简化 <code class="language-plaintext highlighter-rouge">copyin</code> <code class="language-plaintext highlighter-rouge">copyinstr</code></span><a href="#简化-copyin-copyinstr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="实验要点-1"><span class="mr-2">实验要点</span><a href="#实验要点-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>要从用户页表跟进程的内核页表中添加映射，让内核直接从内核页表中读取对应的数据<li>xv6 的用户地址从0往上，而内核地址从较高的地址开始；要限制用户地址小于内核地址的最小值<li>内核的最小地址是 <code class="language-plaintext highlighter-rouge">PLIC</code> 寄存器，值为 <code class="language-plaintext highlighter-rouge">0xC000000</code>，需要防止地址超过 <code class="language-plaintext highlighter-rouge">0xC000000</code><li>在内核映射用户地址操作时，别忘了在每个更改进程映射的点上都要更改内核页表<li>不要忘了将 <code class="language-plaintext highlighter-rouge">userinit</code> 第一个进程中的内核用户页表包含在其内核页表中<li>在内核模式中，内核不能够访问 <code class="language-plaintext highlighter-rouge">PTE_U</code> （只有用户模式才能够访问）<li>-<h6 id="内核页表与物理内存的映射图">内核页表与物理内存的映射图</h6><p>![[xv6 内核页表与物理内存的映射图.png]]</p><h3 id="根本理解"><span class="mr-2">根本理解</span><a href="#根本理解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></ol><h5 id="映射函数"><span class="mr-2">映射函数</span><a href="#映射函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>在这个实验中，最重要的是对于用户进程映射到内核页表中的理解；实际上，在进程的内核页表映射着用户进程的物理地址</p><h3 id="code-2"><span class="mr-2">code</span><a href="#code-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
</pre><td class="rouge-code"><pre>##### `kernel/vm.c`
```c
pagetable_t
kvm_map_kernalpagetable() {
pagetable_t pgtbl = (pagetable_t) kalloc();
memset(pgtbl, 0, PGSIZE);

// uart registers
kvmmap(pgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

// virtio mmio disk interface
kvmmap(pgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
=-=
// // CLINT
// kvmmap(pgtbl, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
=-=
// PLIC
kvmmap(pgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

// map kernel text executable and read-only.
kvmmap(pgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

// map kernel data and the physical RAM we'll make use of.
kvmmap(pgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

// map the trampoline for trap entry/exit to
// the highest virtual address in the kernel.
kvmmap(pgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

return pgtbl;
}

void
kvminit()
{
kernel_pagetable = kvm_map_kernalpagetable();
=-=-
// CLINT
kvmmap(kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
-=-=
}
=-=-
void
kvm_free_mapping(pagetable_t pgtbl) {
for (int i = 0; i &lt; 512; i++) {
	pte_t pte = pgtbl[i];
	if ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W)) == 0) {
	uint64 child = PTE2PA(pte);
	kvm_free_mapping((pagetable_t)child);
	pgtbl[i] = 0;
	}
}
kfree((void*) pgtbl);
}

int
kvm_copy_mapping(pagetable_t src, pagetable_t dst, int start, int sz) {
pte_t *pte;
uint64 pa, i;
uint flags;

for(i = PGROUNDUP(start); i &lt; sz; i += PGSIZE){
	if((pte = walk(src, i, 0)) == 0)
	panic("kvm_copy_mapping: pte should exist");
	if((*pte &amp; PTE_V) == 0)
	panic("kvm_copy_mapping: page not present");
	pa = PTE2PA(*pte);
	flags = PTE_FLAGS(*pte) &amp; ~PTE_U;
	
	if(mappages(dst, i, PGSIZE, pa, flags) != 0){
	goto err;
	}
}
return 0;

err:
uvmunmap(dst, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, 0);
return -1;
}

uint64
kvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
{
if(newsz &gt;= oldsz)
	return oldsz;

if(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz)){
	int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
	uvmunmap(pagetable, PGROUNDUP(newsz), npages, 0);
}

return newsz;
}
-=-=
```

##### `kernel/exec.c`
```c
int
exec(char *path, char **argv)
{
char *s, *last;
int i, off;
uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase;
struct elfhdr elf;
struct inode *ip;
struct proghdr ph;
pagetable_t pagetable = 0, oldpagetable;
struct proc *p = myproc();

begin_op();

if((ip = namei(path)) == 0){
	end_op();
	return -1;
}
ilock(ip);

// Check ELF header
if(readi(ip, 0, (uint64)&amp;elf, 0, sizeof(elf)) != sizeof(elf))
	goto bad;
if(elf.magic != ELF_MAGIC)
	goto bad;

if((pagetable = proc_pagetable(p)) == 0)
	goto bad;

// Load program into memory.
for(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph)){
	if(readi(ip, 0, (uint64)&amp;ph, off, sizeof(ph)) != sizeof(ph))
	goto bad;
	if(ph.type != ELF_PROG_LOAD)
	continue;
	if(ph.memsz &lt; ph.filesz)
	goto bad;
	if(ph.vaddr + ph.memsz &lt; ph.vaddr)
	goto bad;
	uint64 sz1;
	if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0)
	goto bad;
=-=-
	if (sz1 &gt;= PLIC)
	goto bad;
-=-=
	sz = sz1;
	if(ph.vaddr % PGSIZE != 0)
	goto bad;
	if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; 0)
	goto bad;
}
iunlockput(ip);
end_op();
ip = 0;

p = myproc();
uint64 oldsz = p-&gt;sz;

// Allocate two pages at the next page boundary.
// Use the second as the user stack.
sz = PGROUNDUP(sz);
uint64 sz1;
if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0)
	goto bad;
sz = sz1;
uvmclear(pagetable, sz-2*PGSIZE);
sp = sz;
stackbase = sp - PGSIZE;

// Push argument strings, prepare rest of stack in ustack.
for(argc = 0; argv[argc]; argc++) {
	if(argc &gt;= MAXARG)
	goto bad;
	sp -= strlen(argv[argc]) + 1;
	sp -= sp % 16; // riscv sp must be 16-byte aligned
	if(sp &lt; stackbase)
	goto bad;
	if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) &lt; 0)
	goto bad;
	ustack[argc] = sp;
}
ustack[argc] = 0;

// push the array of argv[] pointers.
sp -= (argc+1) * sizeof(uint64);
sp -= sp % 16;
if(sp &lt; stackbase)
	goto bad;
if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) &lt; 0)
	goto bad;

// arguments to user main(argc, argv)
// argc is returned via the system call return
// value, which goes in a0.
p-&gt;trapframe-&gt;a1 = sp;

// Save program name for debugging.
for(last=s=path; *s; s++)
	if(*s == '/')
	last = s+1;
safestrcpy(p-&gt;name, last, sizeof(p-&gt;name));
=-=-
uvmunmap(p-&gt;kernel_pagetable, 0, PGROUNDUP(oldsz) / PGSIZE, 0);
kvm_copy_mapping(pagetable, p-&gt;kernel_pagetable, 0, sz);
-=-=

// Commit to the user image.
oldpagetable = p-&gt;pagetable;
p-&gt;pagetable = pagetable;
p-&gt;sz = sz;
p-&gt;trapframe-&gt;epc = elf.entry;  // initial program counter = main
p-&gt;trapframe-&gt;sp = sp; // initial stack pointer
proc_freepagetable(oldpagetable, oldsz);

vmprint(p-&gt;pagetable, 0);
return argc; // this ends up in a0, the first argument to main(argc, argv)

bad:
if(pagetable)
	proc_freepagetable(pagetable, sz);
if(ip){
	iunlockput(ip);
	end_op();
}
return -1;
}
```
##### `kernel/proc.c`
```c
void
userinit(void)
{
struct proc *p;

p = allocproc();
initproc = p;

// allocate one user page and copy init's instructions
// and data into it.
uvminit(p-&gt;pagetable, initcode, sizeof(initcode));
p-&gt;sz = PGSIZE;
=-=-
kvm_copy_mapping(p-&gt;pagetable, p-&gt;kernel_pagetable, 0, p-&gt;sz);
-=-=
// prepare for the very first "return" from kernel to user.
p-&gt;trapframe-&gt;epc = 0;      // user program counter
p-&gt;trapframe-&gt;sp = PGSIZE;  // user stack pointer

safestrcpy(p-&gt;name, "initcode", sizeof(p-&gt;name));
p-&gt;cwd = namei("/");

p-&gt;state = RUNNABLE;

release(&amp;p-&gt;lock);
}
int
growproc(int n)
{
uint sz;
struct proc *p = myproc();

sz = p-&gt;sz;
if(n &gt; 0){
	int sz1;
	if((sz1 = uvmalloc(p-&gt;pagetable, sz, sz + n)) == 0) {
	return -1;
	}
	=-=-
	if (kvm_copy_mapping(p-&gt;pagetable, p-&gt;kernel_pagetable, sz, sz + n)) {
	return -1;
	}
	-=-=
	sz = sz1;
} else if(n &lt; 0){
=-=-
	uvmdealloc(p-&gt;pagetable, sz, sz + n);
	sz = kvmdealloc(p-&gt;kernel_pagetable, sz, sz + n);
	-=-=
}
p-&gt;sz = sz;
return 0;
}

int
fork(void)
{
int i, pid;
struct proc *np;
struct proc *p = myproc();

// Allocate process.
if((np = allocproc()) == 0){
	return -1;
}
=-=-
// Copy user memory from parent to child.
if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0 ||
	kvm_copy_mapping(np-&gt;pagetable, np-&gt;kernel_pagetable, 0, p-&gt;sz) &lt; 0){
-=-=
	freeproc(np);
	release(&amp;np-&gt;lock);
	return -1;
}
np-&gt;sz = p-&gt;sz;

np-&gt;parent = p;

// copy saved user registers.
*(np-&gt;trapframe) = *(p-&gt;trapframe);

// Cause fork to return 0 in the child.
np-&gt;trapframe-&gt;a0 = 0;

// increment reference counts on open file descriptors.
for(i = 0; i &lt; NOFILE; i++)
	if(p-&gt;ofile[i])
	np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);
np-&gt;cwd = idup(p-&gt;cwd);

safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));

pid = np-&gt;pid;

np-&gt;state = RUNNABLE;

release(&amp;np-&gt;lock);

return pid;
}
```
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/'>计算机</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6s081-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-tag no-text-decoration" >操作系统/6S081/源码解析</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=xv6%20console.c%20%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E5%B2%9A%E9%9B%B2&url=%2Fposts%2F6.S081-lab3-pgtbl%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=xv6%20console.c%20%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E5%B2%9A%E9%9B%B2&u=%2Fposts%2F6.S081-lab3-pgtbl%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F6.S081-lab3-pgtbl%2F&text=xv6%20console.c%20%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20%E5%B2%9A%E9%9B%B2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">muduo 网络库并发框架设计与实现</a><li><a href="/posts/%E5%9F%BA%E4%BA%8E%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">基于双缓冲区的日志系统</a><li><a href="/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a><li><a href="/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a><li><a href="/posts/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E8%AF%AD%E8%A8%80-cpp/">语言/CPP</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6s081-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">操作系统/6S081/源码解析</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">算法/排序</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6s081/">操作系统/6S081</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C-tcp/">网络/TCP</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-allocproc-%E5%87%BD%E6%95%B0/"><div class="card-body"> <em class="small" data-ts="1705718040" data-df="YYYY/MM/DD" > 2024/01/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>xv6 源码解析 - allocproc 函数</h3><div class="text-muted small"><p> #操作系统/6S081/源码解析 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ```C // Look in the process table for an UNUS...</p></div></div></a></div><div class="card"> <a href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-kernelvec-%E6%B1%87%E7%BC%96%E6%A0%87%E7%AD%BE/"><div class="card-body"> <em class="small" data-ts="1705718040" data-df="YYYY/MM/DD" > 2024/01/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>xv6 源码解析 - kernelvec 汇编标签</h3><div class="text-muted small"><p> #操作系统/6S081/源码解析 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 6...</p></div></div></a></div><div class="card"> <a href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-procinit-%E5%87%BD%E6%95%B0/"><div class="card-body"> <em class="small" data-ts="1705718040" data-df="YYYY/MM/DD" > 2024/01/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>xv6 源码解析 - procinit 函数</h3><div class="text-muted small"><p> #操作系统/6S081/源码解析 code // kernel/proc.c // initialize the proc table at boot time. void procinit(void) { struct proc *p; initlock(&amp;amp;pid_lock, &quot;nextpid&quot;); for(p = proc; ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%AE%9E%E7%8E%B0/" class="btn btn-outline-primary" prompt="上一篇"><p>基于双缓冲区的日志系统</p></a> <a href="/posts/xv6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-allocproc-%E5%87%BD%E6%95%B0/" class="btn btn-outline-primary" prompt="下一篇"><p>xv6 源码解析 - allocproc 函数</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E8%AF%AD%E8%A8%80-cpp/">语言/CPP</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6s081-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">操作系统/6S081/源码解析</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">算法/排序</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6s081/">操作系统/6S081</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C-tcp/">网络/TCP</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">ZashJie</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
